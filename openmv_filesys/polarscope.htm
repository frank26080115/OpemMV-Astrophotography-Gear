<html>
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="initial-scale=1" />
<title>OpenMV PolarScope</title>

<style type="text/css">
body
{
    background-color: #000;
    color: #EEE;
    font-size: 10pt;
}
.tbl_platesolve table, th, td {
    border: 1px solid white;
    border-collapse: collapse;
    padding: 2px 10px 2px 10px;
}
.platesolve_green {
    color: lime;
}
.hideable-msg {
    padding-left: 1em;
}
</style>

<script type="text/javascript">

var dataw = 2592;
var datah = 1944;
var def_pix_per_deg = 875.677409 / 2.9063;

var first = true;
var settings = null;
var updateQueue = [];
var lastStatus = null;
var prev_frm = -1;
var old_settings_frm = -1;
var needUiRefresh = false;
var websock_timer = null;

var ghost = null;
var pre_ghost = null;
var simpcali_results = null;
var advcali_data = [];
var advcali_tmp1 = null;
var advcali_tmp2 = null;

var hotpixels = [];

var loadTries = 0;

var refraction = null;

var timeAccel = 0;

function loadSettings(t)
{
    if (platesolver_init !== undefined) {
        platesolver_init();
    }

    if (t == 0) {
        setTimeout(() => { loadSettings(1); }, 500);
        return;
    }

    $.ajax({
        dataType: "json",
        url: "getsettings",
        data: null,
        success: function(data) {
            console.log("settings retrieved");
            console.log(data);
            settings = data;
            try {
                var multi = 10000.0;
                document.getElementById("txt_location").value = (Math.round((settings["latitude"] + Number.EPSILON) * multi) / multi).toString() + " , " + (Math.round((settings["longitude"] + Number.EPSILON) * multi) / multi).toString();
            }
            catch (e) {
                console.log("cannot parse location from settings: " + e.toString());
            }
            document.getElementById("loading").style.display        = "none";
            document.getElementById("loading_failed").style.display = "none";
            document.getElementById("loading_almost").style.display = "block";
            onLoadAll();
        },
        fail: function(jqxhr, textStatus, error) {
            console.log("getsettings failed");
            console.log(txtStatus);
            console.log(error);
            loadSettingsFailed();
        },
        error: function() {
            console.log("getsettings error");
            loadSettingsFailed();
        }
    });
}

function loadSettingsFailed()
{
    loadTries += 1;
    console.log("settings load reattempt " + loadTries);
    document.getElementById("load_tries").innerHTML += ".";
    loadSettings(0);
}

function websock_onmessage(evt)
{
    var jobj = JSON.parse(evt.data);
    endStatusUpdate(jobj);
    if (websock_timer != null) {
        clearTimeout(websock_timer);
    }
    websock_timer = setTimeout(function(){
        console.log("websocket timeout");
        document.getElementById("connection_lost").style.display = "block";
        websocket_init("websocket");
    }, 5000);
}

function websock_onerror(evt)
{
    socket = null;
    console.log("websocket error " + evt);
    document.getElementById("connection_lost").style.display = "block";
    websocket_init("websocket");
}

function getReplyStr() {
    var qstr = "";

    qstr += "zoom=" + get_zoom().toString() + "&";

    if (timeAccel != 0) {
        qstr += "accel_sec=" + timeAccel.toString() + "&";
    }

    if ($( "#chkturnonled-1").prop("checked")) {
        qstr += "use_leds=true&";
    }
    else {
        qstr += "use_leds=false&";
    }

    qstr += "time=" + updateTime();

    if (updateQueue.length > 0)
    {
        if (updateQueue.includes("rand_id") == false) {
            updateQueue.push("rand_id");
            settingsNewRand();
        }

        var i, ql = updateQueue.length;
        var ustr = "";
        for (i = 0; i < ql; i++)
        {
            var k = updateQueue[i];
            try {
                var ap = k + "=" + settings[k];
                if (i != 0) {
                    ustr += "&";
                }
                ustr += ap;
            }
            catch (e) {
                
            }
        }
        qstr += "&" + ustr + "&save=true";
    }

    return qstr;
}

function settingsNewRand()
{
    var rand_id = 0;
    while (rand_id == 0) {
        rand_id = Math.floor(Math.random() * 100000);
    }
    settings["rand_id"] = rand_id;
    if (updateQueue.length > 0)
    {
        if (updateQueue.includes("rand_id") == false) {
            updateQueue.push("rand_id");
        }
    }
}

function endStatusUpdate(obj) {
    console.log("status: " + obj);

    if (obj == null || obj == false || obj == undefined) {
        document.getElementById("connection_lost").style.display = "block";
        //setTimeout(() => { startStatusUpdate(); }, 5000);
        websocket_init("websocket");
    }

    lastStatus = obj;

    document.getElementById("loading_almost").style.display = "none";
    document.getElementById("connection_lost").style.display = "none";
    document.getElementById("showme").style.display = "block";

    // check if the server acknowledges last settings message
    if (updateQueue.length > 0)
    {
        if (updateQueue.includes("rand_id"))
        {
            if ("rand_id" in obj)
            {
                if (obj["rand_id"] == settings["rand_id"]) {
                    updateQueue = [];
                }
            }
        }
    }

    var replyStr = getReplyStr();
    if (socket != null) {
        socket.send(replyStr);
    }

    if (first)
    {
        // TODO: add things to do on first connect
        first = false;
    }

    updateTime();

    if (old_settings_frm + 2 < obj["frm_cnt"]) {
        document.getElementById("camera_hardware_wait").style.display = "none";
    }

    if (prev_frm == obj["frm_cnt"] && needUiRefresh == false) {
        return;
    }
    prev_frm = obj["frm_cnt"];

    refreshUi(obj);
}

function refreshUi(obj)
{
    if (obj == null) {
        obj = lastStatus;
    }
    if (obj == null) {
        return;
    }
    lastStatus = obj;

    if (obj["expo_code"] === 6) {
        document.getElementById("memory_error").style.display = "block";
    }
    else {
        document.getElementById("memory_error").style.display = "none";
    }

    if (obj["expo_code"] === 7) {
        document.getElementById("camera_hardware_error").style.display = "block";
    }
    else {
        document.getElementById("camera_hardware_error").style.display = "none";
    }

    var stars = obj["stars"];
    var star_cnt = stars.length;

    var stats_str = "num of stars: " + star_cnt.toString() + "&nbsp;&nbsp;&nbsp;&nbsp;";

    try {
        stats_str += "image mean: "  + math_roundPlaces(obj["img_mean"], 1).toString() + "/255    \t";
        stats_str += "image stdev: " + math_roundPlaces(obj["img_stdev"], 1).toString() + "/255    \t";
        stats_str += "image max: " + Math.round(obj["img_max"]).toString() + "/255    \t";
        stats_str += "image min: " + Math.round(obj["img_min"]).toString() + "/255    \t";
        if (obj["solution"]) {
            stats_str += "solution stars: " + obj["solution"]["cnt"].toString() + "&nbsp;&nbsp;&nbsp;&nbsp;";
            if (obj["solution"]["cnt"] <= 8 || obj["solution"]["penalty"] > 0) {
                document.getElementById("low_confidence_warning").style.display = "block";
                document.getElementById("low_confidence").innerHTML = "(stars: " + obj["solution"]["cnt"].toString() + " , penalty: " + obj["solution"]["penalty"].toString() + ")";
            }
            else {
                document.getElementById("low_confidence_warning").style.display = "none";
            }
        }
        else {
            document.getElementById("low_confidence_warning").style.display = "none";
        }
    }
    catch (e) {
    }
    stats_str += "exposure code: ";
    var exposure_code = obj["expo_code"];
    stats_str += getExposureCode(exposure_code);
    while (stats_str.includes(" ")) {
        stats_str = stats_str.replace(" ", "&nbsp;");
    }
    document.getElementById("div_histogram").innerHTML = stats_str;

    if (advcali_data.length > 0 && advcali_data.length <= 2)
    {
        var vg = validateSimpleCalib();
        var canCalibrate = vg[0];
        var reason = vg[1];

        //var curCalDataEle = document.getElementById("div_curdata");
        if (obj["solution"] && obj["star_x"] && obj["star_y"] && obj["pole_x"] && obj["pole_y"])
        {
            var s = "Polaris = (" + math_roundPlaces(obj["star_x"], 1) + " , " + math_roundPlaces(obj["star_y"], 1) + ")  ;  NCP = (" + math_roundPlaces(obj["pole_x"], 1) + " , " + math_roundPlaces(obj["pole_y"], 1) + ")";
            if (canCalibrate == false && ghost != null) {
                s += " ; cannot calibrate with this" + reason;
            }
            else if (canCalibrate == true && simpcali_results != null) {
                s += "<br />New Center = (" + math_roundPlaces(simpcali_results.cent_x, 1) + " ," + math_roundPlaces(simpcali_results.cent_y, 1) + ")";
            }
            //curCalDataEle.innerHTML = s;
            pre_ghost = {star_x: obj["star_x"], star_y: obj["star_y"], pole_x: obj["pole_x"], pole_y: obj["pole_y"]};
            $("#btn_savecalpt" ).button( "option", "disabled", false );
        }
        else
        {
            //curCalDataEle.innerHTML = "nothing";
            pre_ghost = null;
            canCalibrate = false;
            $("#btn_savecalpt" ).button( "option", "disabled", true );
        }

        if (ghost != null)
        {
            $("#btn_clearcalpts" ).button( "option", "disabled",  false);
        }
        else
        {
            canCalibrate = false;
            $("#btn_clearcalpts" ).button( "option", "disabled", true );
        }

        $("#btn_calibrate" ).button( "option", "disabled", canCalibrate == false );
    }
    else
    {
        ghost = null;
        simpcali_results = null;

        if (advcali_data.length < 3) {
            $("#btn_calibrate" ).button( "option", "disabled", true );
            advcali_tmp1 = null;
            advcali_tmp2 = null;
        }
        else {
            $("#btn_calibrate" ).button( "option", "disabled", false );
            advcali_tmp1 = circle_fit(advcal_getCoords(advcali_data, "pole"), [dataw, datah]);
            advcali_tmp2 = circle_fit(advcal_getCoords(advcali_data, "star"), [dataw, datah]);
        }

        if (obj["solution"] && obj["star_x"] && obj["star_y"] && obj["pole_x"] && obj["pole_y"]) {
            $("#btn_savecalpt" ).button( "option", "disabled", false );
        }
        else {
            $("#btn_savecalpt" ).button( "option", "disabled", true );
        }

        if (advcali_data.length > 0) {
            $("#btn_clearcalpts" ).button( "option", "disabled", false );
        }
        else {
            $("#btn_clearcalpts" ).button( "option", "disabled", true );
        }
    }
    draw_svg(obj, get_zoom(), needUiRefresh, false, simpcali_results);

    needUiRefresh = false;
}

function validateSimpleCalib()
{
    simpcali_results = math_getGhostResults(lastStatus, ghost);
    var canCalibrate = pre_ghost != null;
    var reason = "";
    if (simpcali_results != null)
    {
        if (simpcali_results.cent_x != null && simpcali_results.cent_x != 0)
        {
            // being too off-center will make plate-solving much harder
            if (simpcali_results.cent_x < dataw * 0.33 || simpcali_results.cent_x > dataw * 0.67) {
                canCalibrate = false;
                reason = ", too off-center";
            }
            if (simpcali_results.cent_y < datah * 0.33 || simpcali_results.cent_y > datah * 0.67) {
                canCalibrate = false;
                reason = ", too off-center";
            }

            // we want the angle to be close to perpendicular
            // if there lines where parallel then there would be no solution
            // perfectly perpendicular lines would give a very accurate solution
            if (math_isNear90Apart(simpcali_results.angle, 70) == false) {
                canCalibrate = false;
                reason = ", angle not good";
            }
        }
        else {
            canCalibrate = false;
            reason = ", calculation failed";
        }
    }
    else {
        reason = ", unable to calculate";
    }
    return [canCalibrate, reason];
}

function advcal_getCoords(data, key) {
    var x = [];
    data.forEach(function (ele, idx) {
        x.push(ele[key]);
    });
    return x;
}

function updateTime() {
    // warning, month is 0-11
    var epoch2000 = new Date(Date.UTC(2000, 0, 1));
    var epoch2020 = new Date(Date.UTC(2020, 7, 10, 20, 40, 46));
    date = new Date();
    var nowEpoch = new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds()));
    var nowEpoch2000 = nowEpoch - epoch2000;
    nowEpoch2000 += timeAccel * 1000;
    var nowEpoch2020 = nowEpoch - epoch2020;
    nowEpoch2000 = Math.round(nowEpoch2000 / 1000.0);
    document.getElementById("span_utc_time").innerHTML = date.toUTCString();
    document.getElementById("span_utc_time_epoch").innerHTML = nowEpoch2000.toString();
    document.getElementById("span_utc_time_epoch2020").innerHTML = Math.round(nowEpoch2020 / 1000.0).toString();
    return nowEpoch2000;
}

function errorStatusUpdate() {
    console.log("getstate error\r\n");
    document.getElementById("connection_lost").style.display = "block";
    document.getElementById("showme").style.display          = "block";
    setTimeout(() => { startStatusUpdate(); }, 5000);
}

function failStatusUpdate(jqxhr, textStatus, error) {
    console.log("getstate failed\r\n" + textStatus.toString() + "\r\n" + error.toString());
    document.getElementById("connection_lost").style.display = "block";
    document.getElementById("showme").style.display          = "block";
    setTimeout(() => { startStatusUpdate(); }, 5000);
}

function getExposureCode(exposure_code) {
    if (exposure_code == 0) {
        return "correct";
    }
    else if (exposure_code == -1) {
        return "too dark";
    }
    else if (exposure_code == -2) {
        return "no image";
    }
    else if (exposure_code == 1) {
        return "too bright";
    }
    else if (exposure_code == 2) {
        return "too noisy";
    }
    else if (exposure_code == 3) {
        return "movement";
    }
    else if (exposure_code == 4) {
        return "big blob";
    }
    else if (exposure_code == 5) {
        return "too many stars";
    }
    else if (exposure_code == 6) {
        return "INTERNAL MEMORY ERROR";
    }
    else if (exposure_code == 7) {
        return "CAMERA HARDWARE ERROR";
    }
    return "unknown";
}

function getLocation() {
    var xele = document.getElementById("txt_location");
    var x = xele.value;

    // split the user input into two halves
    var split;
    if (x.includes(",")) {
        split = x.split(",");
    }
    else if (x.includes(";")) {
        split = x.split(";");
    }
    else if (x.includes("/")) {
        split = x.split("/");
    }
    else if (x.includes("\t")) {
        split = x.split("\t");
    }
    else {
        xele.style.backgroundColor = "pink";
        return false;
    }
    if (split.length != 2) {
        xele.style.backgroundColor = "pink";
        return false;
    }

    // we expect the two numbers to be in a specific order, but putting a direction could change that order
    var s0 = split[0].trim().toUpperCase();
    var s1 = split[1].trim().toUpperCase();
    if ((s0.includes("N") || s0.includes("S")) && (s1.includes("E") || s1.includes("W"))) {
        var s3 = s0;
        s0 = s1;
        s1 = s3;
    }

    // let magellan take care of the rest of the parsing
    var latitude  = magellan(s0).latitude();
    var longitude = magellan(s1).longitude();
    if (longitude == null || latitude == null) {
        xele.style.backgroundColor = "pink";
        return false;
    }
    xele.style.backgroundColor = "";
    return [parseFloat(longitude.toDD()), parseFloat(latitude.toDD())];
}

function queueSettingsUpdate(key) {
    if (updateQueue.includes(key) == false) {
        updateQueue.push(key);
        console.log("queueing setting update for " + key);
    }
    settingsNewRand();
}

function computeRefraction() {
    if ($( "#chkrefraction-1").prop("checked") == false) {
        //document.getElementById("refraction_info").innerHTML = "";
        refraction = null;
        //return;
    }
    var loc = getLocation();
    if (loc == false) {
        document.getElementById("refraction_info").innerHTML = "Unable to calculate refraction due to invalid location coordinates";
        refraction = null;
        return;
    }
    refraction = math_getRefraction(loc[1], $("#slider_pressure").slider("option", "value") / 10.0, $("#slider_temperature").slider("option", "value"));
    var fmtRefraction = "" + refraction[0];
    while (true) {
        var i, c = 0;
        for (i = 0; i < fmtRefraction.length; i++) {
            if (fmtRefraction[i] != '0') {
                c += 1;
            }
        }
        if (c < 3) {
            break;
        }
        if (fmtRefraction.length < 8) {
            break;
        }
        fmtRefraction = fmtRefraction.substring(0, fmtRefraction.length - 1);
    }
    var txtinfo = "Calculated Refraction: " + fmtRefraction + "&deg; = " + math_roundPlaces(refraction[1], 2) + " arcmin";
    if (lastStatus != null && lastStatus != false) {
        if (lastStatus["solution"]) {
            txtinfo += " = " + math_roundPlaces(lastStatus["pix_per_deg"] * refraction[0], 1) + " camera pixels";
        }
        else {
            txtinfo += " = " + math_roundPlaces(def_pix_per_deg * refraction[0], 1) + " camera pixels";
        }
    }
    else {
        txtinfo += " = " + math_roundPlaces(def_pix_per_deg * refraction[0], 1) + " camera pixels";
    }
    document.getElementById("refraction_info").innerHTML = txtinfo;
}

function checkHotPixel(star) {
    if (hotpixels == undefined) {
        return false;
    }
    if (hotpixels == null || hotpixels == false) {
        return false;
    }
    if (hotpixels.length <= 0) {
        return false;
    }
    var i, cnt = hotpixels.length;
    for (i = 0; i < cnt; i++) {
        var v = math_getVector([star.cx, star.cy], hotpixels[i]);
        if (v[0] < 2) {
            return true;
        }
    }
    return false;
}

function awaitCamReset() {
    document.getElementById("camera_hardware_wait").style.display = "block";
    if (lastStatus == null) {
        old_settings_frm = -1;
    }
    else {
        old_settings_frm = lastStatus["frm_cnt"];
    }
}

function demoCalibration()
{
    if (ghost == null) {
        alert("ERROR: cannot demo calibration without first data point");
        return;
    }
    var v = math_getVector([ghost.star_x, ghost.star_y], [ghost.pole_x, ghost.pole_y]);
    if (advcali_data.length == 1)
    {
        console.log("demo calibration simple mode");
        var needGood = Math.random() < 0.5;
        var tries = 0;
        while (tries < 50)
        {
            ghost.star_x = Math.round((dataw * 0.2) + (Math.random() * dataw * 0.6));
            ghost.star_y = Math.round((datah * 0.2) + (Math.random() * datah * 0.6));
            var p = math_movePointTowards([ghost.star_x, ghost.star_y], [v[0], v[1] + (90.0 * (-1.5 + (Math.random() * 3.0)))]);
            ghost.pole_x = Math.round(p[0]);
            ghost.pole_y = Math.round(p[1]);
            var ncal = {pole: [ghost.pole_x, ghost.pole_y], star: [ghost.star_x, ghost.star_y]};
            if (needGood) {
                var vg = validateSimpleCalib();
                if (vg[0]) {
                    advcali_data.push(ncal);
                    break;
                }
            }
            else if (needGood == false && ghost.pole_x > 0 && ghost.pole_x < dataw && ghost.pole_y > 0 && ghost.pole_y < datah) {
                advcali_data.push(ncal);
                break;
            }
            tries += 1;
        }
    }
    else
    {
        console.log("demo calibration advanced mode");
        var demo_x = Math.round((dataw * 0.2) + (Math.random() * dataw * 0.6));
        var demo_y = Math.round((datah * 0.2) + (Math.random() * datah * 0.6));
        var demo_r = Math.round((datah * 0.1) + (Math.random() * datah * 0.3));
        var demo_cnt = 5 + Math.round(Math.random() * 15);
        var demo_noise = 10;
        advcali_data = [];
        var i;
        for (i = 0; i < demo_cnt; i++) {
            var np = math_movePointTowards([demo_x, demo_y], [demo_r - (demo_noise / 2) + (Math.random() * demo_noise), Math.random() * 360]);
            var ns = math_movePointTowards([demo_x, demo_y], [demo_r + v[0] - (demo_noise / 2) + (Math.random() * demo_noise), Math.random() * 360]);
            var ncal = {pole: np, star: ns};
            advcali_data.push(ncal);
        }
        refreshUi(null);
    }
}

function makeSlider(id, minval, maxval, defval, stepval, slide_func)
{
    if (defval < minval) {
        defval = minval;
    }
    if (defval > maxval) {
        defval = maxval;
    }

    var handle = $( "#" + id + "_handle" );
    $( "#" + id ).slider({
      create: function() {
        handle.text( $( this ).slider( "value" ) );
      },
      min: minval,
      max: maxval,
      step: stepval,
      value: defval,
      slide: function( event, ui ) {
        handle.text( ui.value );
        if (slide_func) {
            slide_func(this, event, ui);
        }
      }
    });
}

function onLoadAll()
{
    document.getElementById("loading").style.display = "none";
    $( "#top_ctrls" ).droppable();
    $( "#accordion" ).accordion({heightStyle: "content"});

    $( "#span_zoomopts input" ).checkboxradio();
    $( "#viewmode-1").prop("checked", true).checkboxradio("refresh");
    $( "#fldset_speed input" ).checkboxradio();
    $( "#chkrefraction-1" ).checkboxradio().prop("checked", settings["use_refraction"]).on("change", function () {
        var x = getLocation();
        var y = $( "#chkrefraction-1").prop("checked");
        if (x == false && y == true) {
            $( "#chkrefraction-1").prop("checked", false).checkboxradio("refresh");
            alert("ERROR: Proper location coordinates required for refraction calculations");
            return;
        }
        if (settings["use_refraction"] !== y) {
            settings["use_refraction"] = y;
            queueSettingsUpdate("use_refraction");
        }
        if (y) {
            computeRefraction();
        }
        else {
            document.getElementById("refraction_info").innerHTML = "";
        }
        refreshUi(null);
    }).checkboxradio("refresh");

    makeSlider("slider_gain", 0, 128, settings["gain"], 8, function(obj, event, ui) {
        console.log("slider_gain: " + ui.value);
        settings["gain"] = ui.value;
        queueSettingsUpdate("gain");
        awaitCamReset();
    });
    makeSlider("slider_shutter", 0, 1500, settings["shutter"] / 1000, 100, function(obj, event, ui) {
        console.log("slider_shutter: " + ui.value);
        settings["shutter"] = ui.value * 1000;
        queueSettingsUpdate("shutter");
        awaitCamReset();
    });
    makeSlider("slider_thresh", 0, 255, settings["thresh"], 1, function(obj, event, ui) {
        console.log("slider_thresh: " + ui.value);
        settings["thresh"] = ui.value;
        queueSettingsUpdate("thresh");
    });
    makeSlider("slider_pressure", 500, 1100, 1010, 1, function(obj, event, ui) {
        console.log("slider_pressure: " + ui.value);
        var x = ui.value / 10;
        document.getElementById("span_pressure").innerHTML = x + " kPa";
        computeRefraction();
        refreshUi(null);
    });
    document.getElementById("span_pressure").innerHTML = "101 kPa";
    makeSlider("slider_temperature", -50, 50, 10, 1, function(obj, event, ui) {
        console.log("slider_temperature: " + ui.value);
        document.getElementById("span_temperature").innerHTML = ui.value + "&deg;C";
        computeRefraction();
        refreshUi(null);
    });
    document.getElementById("span_temperature").innerHTML = "10&deg;C";

    $("#btn_streamimg" ).button().click(function( event ) {
        console.log("click btn_streamimg");
        window.location.href = "/stream";
    });

    $("#btn_time_update" ).button().click(function( event ) {
        console.log("click btn_time_update");
        settings["time"] = updateTime();
        queueSettingsUpdate("time");
        refreshUi(null);
    });

    $("#btn_time_accelerate" ).button().click(function( event ) {
        console.log("click btn_time_accelerate");
        timeAccel += 60 * 60;
        refreshUi(null);
    });

    $("#btn_location_update" ).button().click(function( event ) {
        console.log("click btn_location_update");
        var x = getLocation();
        if (x != false) {
            console.log(x[0] + " ; " + x[1]);
            settings["longitude"] = x[0];
            settings["latitude"] = x[1];
            document.getElementById("txt_location").style.backgroundColor = "#7FAF00";
            settings["time"] = updateTime();
            queueSettingsUpdate("time");
            queueSettingsUpdate("longitude");
            queueSettingsUpdate("latitude");
        }
        refreshUi(null);
    });

    $("#btn_savecalpt" ).button().click(function( event ) {
        console.log("click btn_savecalpt");

        if (lastStatus != null) {
            if (lastStatus["solution"] && lastStatus["pole_x"] && lastStatus["pole_y"] && lastStatus["pole_x"] && lastStatus["pole_y"]) {
                var np = [lastStatus["pole_x"], lastStatus["pole_y"]];
                var ns = [lastStatus["star_x"], lastStatus["star_y"]];
                var tooClose = false;
                advcali_data.forEach(function(ele, idx){
                    var v1 = math_getVector(np, ele.pole);
                    var v2 = math_getVector(ns, ele.star);
                    if (v1[0] < 5 && v2[0] < 5) {
                        tooClose = true;
                    }
                });
                var ncal = {pole: np, star: ns};
                if (tooClose == false) {
                    advcali_data.push(ncal);
                    if (advcali_data.length <= 1) {
                        ghost = {star_x: ns[0], star_y: ns[1], pole_x: np[0], pole_y: np[1]};
                    }
                    refreshUi(null);
                }
                else {
                    alert("Error: calibration snapshot coordinate too close to existing coordinate, rotate more");
                }
            }
            else {
                alert("Error: need to identify Polaris for calibration");
            }
        }
        else {
            alert("Error: need to identify Polaris for calibration");
        }

        // calibrate button is enabled when the solution is checked against
        refreshUi(null);
    });

    $("#btn_clearcalpts").button().click(function( event ) {
        console.log("click btn_clearcalpts");
        advcali_data = [];
        ghost = null;
        $("#btn_calibrate" ).button( "option", "disabled", true );
        refreshUi(null);
    });

    $("#btn_calibrate").button().click(function( event ) {
        console.log("click btn_calibrate");
        var sendme = false;
        if (advcali_data.length >= 3) {
            advcali_tmp1 = circle_fit(advcal_getCoords(advcali_data, "pole"), [dataw, datah]);
            advcali_tmp2 = circle_fit(advcal_getCoords(advcali_data, "star"), [dataw, datah]);
            var use1 = false;
            var use2 = false;
            if (advcali_tmp1.avg > 150 && advcali_tmp1.stdev < 20) {
                use1 = true;
            }
            if (advcali_tmp2.avg > 150 && advcali_tmp2.stdev < 20) {
                use2 = true;
            }

            if (use1 && use2) {
                var v = math_getVector(advcali_tmp1.coord, advcali_tmp2.coord);
                if (v[0] > 20) {
                    console.log("warning: calibration circles too far apart");
                    if (advcali_tmp1.avg > advcali_tmp2.avg) {
                        use2 = false;
                    }
                    else {
                        use1 = false;
                    }
                }
            }

            if (use1 && use2) {
                settings["center_x"] = (advcali_tmp1.coord[0] + advcali_tmp2.coord[0]) / 2;
                settings["center_y"] = (advcali_tmp1.coord[1] + advcali_tmp2.coord[1]) / 2;
                sendme = true;
            }
            else if (use1) {
                settings["center_x"] = advcali_tmp1.coord[0];
                settings["center_y"] = advcali_tmp1.coord[1];
                sendme = true;
            }
            else if (use2) {
                settings["center_x"] = advcali_tmp2.coord[0];
                settings["center_y"] = advcali_tmp2.coord[1];
                sendme = true;
            }
            else {
                alert("ERROR: bad data for calibration!");
            }
        }
        else if (simpcali_results != null)
        {
            if (simpcali_results.cent_x != 0 && simpcali_results.cent_x != null && simpcali_results.cent_y != 0 && simpcali_results.cent_y != null)
            {
                if (math_isNear90Apart(simpcali_results.angle, 70))
                {
                    settings["center_x"] = simpcali_results.cent_x;
                    settings["center_y"] = simpcali_results.cent_y;
                    sendme = true;
                }
                else
                {
                    alert("ERROR: angle for calibration is bad!");
                }
            }
            else {
                alert("ERROR: no solution for calibration!");
            }
        }
        else {
            alert("ERROR: no solution for calibration!");
        }
        if (sendme) {
            queueSettingsUpdate("center_x");
            queueSettingsUpdate("center_y");
            document.getElementById("txt_override_center_x").setAttribute("value", math_roundPlaces(settings["center_x"], 1));
            document.getElementById("txt_override_center_y").setAttribute("value", math_roundPlaces(settings["center_y"], 1));
            alert("calibration done!");
        }
        refreshUi(null);
    });

    $("#btn_hotpixels").button().click(function( event ) {
        console.log("click btn_hotpixels");
        hotpixels = [];
        var pixstr = "";
        var settingsStr = "";
        if (lastStatus != null) {
            var stars = lastStatus["stars"];
            stars.forEach(function(ele, idx) {
                //if (ele["brightness"] % 2 == 1) // odd number means contains saturated pixel
                // nevermind, a hot pixel isn't necessarily saturated
                {
                    hotpixels.push([ele["cx"], ele["cy"]]);
                }
            });
        }
        else {
            pixstr = "Error: no data from camera";
        }
        var divele = document.getElementById("hotpixel_list");
        if (hotpixels.length > 0)
        {
            pixstr += "<ol>";
            hotpixels.forEach(function(ele, idx) {
                pixstr += "<li>( " + math_roundPlaces(ele[0], 1) + " , " + math_roundPlaces(ele[1], 1) + " )</li>";
                settingsStr += math_roundPlaces(ele[0], 1) + "," + math_roundPlaces(ele[1], 1) + ";";
            });
            pixstr += "</ol>";
            settings["hotpixels"] = settingsStr;
            queueSettingsUpdate("hotpixels");
        }
        else
        {
            pixstr = "No hot-pixels detected by camera";
        }
        divele.innerHTML = pixstr;
    });

    $("#btn_forgethotpixels").button().click(function( event ) {
        console.log("click btn_forgethotpixels");
        hotpixels = [];
        var divele = document.getElementById("hotpixel_list");
        divele.innerHTML = "";
        settings["hotpixels"] = "";
        queueSettingsUpdate("hotpixels");
    });

    document.getElementById("txt_override_center_x").setAttribute("min", math_roundPlaces(dataw / 4, 1));
    document.getElementById("txt_override_center_x").setAttribute("max", math_roundPlaces(dataw - (dataw / 4), 1));
    document.getElementById("txt_override_center_x").setAttribute("value", math_roundPlaces(settings["center_x"], 1));
    document.getElementById("txt_override_center_y").setAttribute("min", math_roundPlaces(datah / 4, 1));
    document.getElementById("txt_override_center_y").setAttribute("max", math_roundPlaces(datah - (datah / 4), 1));
    document.getElementById("txt_override_center_y").setAttribute("value", math_roundPlaces(settings["center_y"], 1));
    $("#btn_override_center").button().click(function( event ) {
        console.log("click btn_override_center");
        try {
            var cx = parseFloat(document.getElementById("txt_override_center_x").value);
            var cy = parseFloat(document.getElementById("txt_override_center_y").value);
            if (isNaN(cx) && isNaN(cy)) {
                alert("Failed to parse center coordinates");
                return;
            }
            else if (isNaN(cx)) {
                alert("Failed to parse center X coordinate");
                return;
            }
            else if (isNaN(cy)) {
                alert("Failed to parse center Y coordinate");
                return;
            }
            if ((cx < 0 || cx > dataw) && (cy < 0 || cy > datah)) {
                alert("Failed: center coordinates out of range");
                return;
            }
            else if (cx < 0 || cx > dataw) {
                alert("Failed: center X coordinate out of range");
                return;
            }
            else if (cy < 0 || cy > datah) {
                alert("Failed: center Y coordinate out of range");
                return;
            }
            ghost = null;
            pre_ghost = null;
            $("#btn_calibrate" ).button( "option", "disabled", true );
            document.getElementById("div_caldata").innerHTML = "nothing";
            refreshUi(null);
            settings["center_x"] = cx;
            settings["center_y"] = cy;
            queueSettingsUpdate("center_x");
            queueSettingsUpdate("center_y");
            alert("new center coordinates set!");
            return;
        }
        catch (e) {
            alert("Failed to set center coordinate override values");
            return;
        }
    });

    document.getElementById("txt_location").onchange = function() {
        getLocation(); // just to validate and colorize
        computeRefraction();
        refreshUi(null);
    };

    $( "#chkturnonled-1" ).checkboxradio().prop("checked", true).on("change", function () {
        // TODO
    }).checkboxradio("refresh");

    $(window).on('resize', function(e) {
        needUiRefresh = true; // this will force a re-scaling of the drawn view
    });

    computeRefraction();

    //setTimeout(() => { startStatusUpdate(); }, 1000);
    websocket_init("websocket");
}

</script>

</head>
<body onload="loadSettings(0);">
<div id="loading"><h2>OpenMV PolarScope</h2><br /><h2>Loading, Please Wait! <span id="load_tries"></span></h2></div>
<div id="loading_failed" style="display:none;"><h1>Loading FAILED! Please refresh the page.</h1></div>
<div id="loading_almost" style="display:none;"><h2>OpenMV PolarScope</h2><br /><h2>Settings loaded! Waiting for star data...</h2></div>
<div id="showme" style="display:none;">

<div style="width:100%"><fieldset style="padding-top: 1em;"><legend>OpenMV PolarScope</legend><div id="viewme" style="display: inline-block; width:100%; padding: 0 0 0 0; margin: 0 0 0 0;"><div id="viewmesvg" style="top: 0; left: 0; display: block;">&nbsp;&nbsp;Please wait for image...</div>
</div></fieldset></div>

<div id="top_ctrls">
    <div><fieldset id="fldset_zoom"><legend>Zoom</legend>
        <span id="span_zoomopts">
        <label for="viewmode-1">1x</label>
        <input type="radio" name="viewmode-1" id="viewmode-1" />
        <label for="viewmode-2">2x</label>
        <input type="radio" name="viewmode-1" id="viewmode-2" />
        <label for="viewmode-3">4x</label>
        <input type="radio" name="viewmode-1" id="viewmode-3" />
        <label for="viewmode-4">8x</label>
        <input type="radio" name="viewmode-1" id="viewmode-4" /></span>
        <button id="btn_streamimg">Stream Image Full Screen</button>
    </fieldset></div>

    <div><fieldset id="fldset_centcali"><legend>Center Calibration</legend>
        <button id="btn_savecalpt">Save Cal. Pt.</button>&nbsp;&nbsp;<button id="btn_calibrate">Calibrate</button>&nbsp;&nbsp;<button id="btn_clearcalpts">Clear Cal. Pts.</button>
    </fieldset></div>
</div>

<div id="connection_lost" class="ui-widget" style="display: none;"><div id="connection_lost_inner" class="hideable-msg ui-state-error ui-corner-all .ui-state-error-text" ><p>Connection LOST! Attempting to re-establish...</p></div></div>
<div id="memory_error" class="ui-widget" style="display: none;"><div id="memory_error_inner" class="hideable-msg ui-state-error ui-corner-all .ui-state-error-text" ><p>INTERNAL MEMORY ERROR! Please check the camera exposure settings!</p></div></div>
<div id="camera_hardware_error" class="ui-widget" style="display: none;"><div id="camera_hardware_error_inner" class="hideable-msg ui-state-error ui-corner-all .ui-state-error-text" ><p>CAMERA HARDWARE ERROR! Please check the camera exposure settings.<br />Lower the shutter time.<br />Do a full power-off-power-on reset if the problem is not solved.</p></div></div>
<div id="camera_hardware_wait" class="ui-widget" style="display: none;"><div id="camera_hardware_wait_inner" class="hideable-msg ui-state-error ui-corner-all .ui-state-error-text" ><p>WAITING for camera to load new exposure settings...</p></div></div>
<div id="low_confidence_warning" class="ui-widget" style="display: none;"><div id="low_confidence_warning_inner" class="hideable-msg ui-state-error ui-corner-all .ui-state-error-text" ><p>Warning: Polaris identified but with low confidence. <span id="low_confidence"></span></p></div></div>

<div id="accordion">
  <h3 id="title_platesolve">Welcome</h3>
  <div>
    <p>The image above shows the stars. If the star Polaris is detected, it will show up as a green dot, and a red target will appear at where the North Celestial Pole is. The yellow cross-hair is where the camera is pointed at. To achieve polar alignment, adjust your mount until the yellow cross-hair is in the center of the red target.</p>
    <p>Use the zoom function to achieve greater precision. Use the image stream to adjust focus. If stars are not detected properly, adjust the camera exposure settings (see below).</p>
    <p>The camera center point (the yellow cross-hair position) must be calibrated if the camera is removed from the mount. For trackers like the Star Adventurer and SkyGuider, this means you need to recalibrate every night. For go-to equatorial mounts, you only need to calibrate when you attach the camera to the mount.</p>
    <p>There's a blinking LED on the camera that you may turn off if it gets too annoying.</p>
    <p><label for="chkturnonled-1">Turn ON LED?</label>
    <input type="checkbox" name="chkturnonled-1" id="chkturnonled-1"></p>
  </div>
  <h3>Camera Exposure</h3>
  <div>
    <div><fieldset><legend>Statistics</legend>
    <div id="div_histogram"></div>
    </fieldset></div>
    <div><fieldset><legend>Gain: <span id="slider_gain_handle"></span> dB</legend>
        <div id="slider_gain"></div>
    </fieldset></div>
    <div><fieldset><legend>Shutter: <span id="slider_shutter_handle"></span> ms</legend>
        <div id="slider_shutter"></div>
    </fieldset></div>
    <div><fieldset><legend>Star Threshold: <span id="slider_thresh_handle"></span>/255</legend>
        <div id="slider_thresh"></div>
    </fieldset></div>
  </div>
  <h3 id="title_platesolve">Plate Solve</h3>
  <div>
    <p>This camera has a database of about 2740 stars that are within 45&deg; of Polaris, and can attempt to identify about 500 of them (one that are bright, B-mag &lt;= 5). If a star has been identified, you can try navigating a sky map with the identified star.</p>
    <p>This algorithm can be painfully slow, but it is searching from Polaris and outwards. Thus, the closer you point towards Polaris, you can stop the calculations earlier.</p>
    <p><button id="btn_platesolve">Plate Solve</button><button id="btn_platesolvehalt">Stop</button></p>
    <div><fieldset><legend>Solution</legend><div id="div_platesolvesolution"></div></fieldset></div>
  </div>
  <h3>Center Calibration Help</h3>
  <div>
    <p>The center of the camera view may not be perfectly aligned with the center-of-rotation of your star tracker. At least two images of Polaris is required to calibrate the center-of-rotation. For a quick calibration, the two images should be rotated about 90&deg; apart. For a more precise calibration, use many points that encompass an entire circle.</p>
    <p>To start, rotate your star tracker's Right-Ascension (RA) to a position towards the west. Register the data by clicking the "Save Cal. Pt." button when you are satisfied. Then, rotate your star tracker's RA towards the east, and click the "Save Cal. Pt." button again to add a new data-point. The display will show the saved points and estimated new calibration (shown in blue). Click the "calibrate" button when you are satisfied.</p>
    <p>Avoid using your hands to make these movements, use electronic control if possible. Do not move your tripod or adjust your mount during these movements. If the center-of-rotation is too far away from the center-of-view, you may need to adjust the mounting of the camera.</p>
    <p>The calibration algorithm actually works better if you are not already polar-aligned while saving the calibration points. The points you save will form a curve, and it's better if this curve is larger, at least it needs some room for a decent circle to exist.</p>
    <div><fieldset><legend>Manual Override Center</legend>
        <div>USE WITH CAUTION! Specify a particular coordinate for the center point<div style="font-family:monospace;">X:&nbsp;<input type="number" name="txt_override_center_x" id="txt_override_center_x" style="width: 50%;" min="0" max="4000" step="0.1"/><br />Y:&nbsp;<input type="number" name="txt_override_center_y" id="txt_override_center_y" style="width: 50%;" min="0" max="4000" step="0.1" /></div><div><button id="btn_override_center">Override</button></div></div>
    </fieldset></div>
  </div>
  <h3>Time and Location</h3>
  <div>
    <div><fieldset><legend>Time and Date</legend><div><p>UTC Time: <span id="span_utc_time"></span></p><p>Epoch Seconds: <span id="span_utc_time_epoch"></span></p><p style="display: none;">Seconds Since 2020-Aug-10, 20:40:53&nbsp;= <span id="span_utc_time_epoch2020"></span></p><p style="display: none;"><button id="btn_time_update">Update</button></p><p style="display: none;"><button id="btn_time_accelerate">Accelerate</button></p></div></fieldset></div>
    <div><fieldset><legend>Location</legend><div><p>type in or paste in coordinates</p><p>latitude, longitude</p><p>comma separated, multiple formats supported (automatically detected)</p><p><input type="text" name="txt_location" id="txt_location" style="width: 100%;" /><button id="btn_location_update">Save</button></p></div></fieldset></div>
    <p>These bits of info are used to calculate the position of Polaris, the camera orientation, and the atmospheric refraction.</p>
    <div><fieldset><legend>Atmosphere Conditions</legend><div><p>Pressure and temperature does affect the air's index of refraction, by very little amounts. Default values are 101 kPa and 10&deg;C.</p>
        <p><fieldset><legend>Pressure: <span id="span_pressure"></span></legend><div id="slider_pressure"></div></fieldset></p>
        <p><fieldset><legend>Temperature: <span id="span_temperature"></span></legend><div id="slider_temperature"></div></fieldset></p>
    <p></p></div></fieldset></div>
    <p><label for="chkrefraction-1">Apply Refraction Compensation?</label>
    <input type="checkbox" name="chkrefraction-1" id="chkrefraction-1"></p>
    <p id="refraction_info"></p>
  </div>
  <h3>Hot Pixels</h3>
  <div>
    <p>If the camera gets too hot, there will be pixels that appear to be stuck as white. These stuck pixels will be falsely detected as stars. You will notice these pixels when you see stars that do not move even though you are moving the camera around.</p>
    <p>It is possible to memorize which pixels are stuck so that they are removed from the list of stars. To do so: <ol><li>turn up the gain and shutter time slightly</li><li>cover up the camera completely</li><li>click the "capture hot pixels" button</li><li>restore your original settings</li></ol></p>
    <p>Think of this as taking a "dark frame" but not really the same thing.</p>
    <p>If a hot pixel is near where an important star exists, then rotate the camera.</p>
    <p><button id="btn_hotpixels">Capture Hot Pixels</button><button id="btn_forgethotpixels">Forget Hot Pixels</button></p>
    <p><fieldset><legend>Hot Pixel List</legend><div id="hotpixel_list"></div></fieldset></p>
  </div>
</div><!-- accordion -->
</div><!-- showme -->
</body>
</html>