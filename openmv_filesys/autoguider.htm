<html>
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="initial-scale=1" />
<title>OpenMV AutoGuider</title>

<!-- ignore -->
<script type="application/javascript" src="web/jquery-3.5.1.min.js"></script>
<script type="application/javascript" src="web/jquery-ui-1.12.1.min.js"></script>
<script type="application/javascript" src="web/jquery.cftoaster.1.0.1.min.js"></script>
<script type="application/javascript" src="web/chartist.min.js"></script>
<script type="application/javascript" src="web/mathutils.js"></script>
<script type="application/javascript" src="web/websocketutils.js"></script>
<script type="application/javascript" src="web/autoguider_utils.js"></script>
<script type="application/javascript" src="web/draw_guideerror.js"></script>
<script type="application/javascript" src="web/draw_starprofile.js"></script>
<link rel="stylesheet" href="web/jquery-ui-1.12.1-darkness.css" />
<link rel="stylesheet" href="web/jquery.cftoaster.1.0.1.css" />
<link rel="stylesheet" href="web/chartist.min.css" />
<!-- end ignore -->

<style type="text/css">
body
{
    background-color: #000;
    color: #EEE;
    font-size: 10pt;
}
.hideable-msg {
    padding-left: 1em;
}

.ct-series-a .ct-line, .ct-series-a .ct-point { stroke:#FF4444; }
.ct-series-b .ct-line, .ct-series-b .ct-point { stroke:#4488FF; }
.ct-series-c .ct-area { fill-opacity: 0.5; }
.ct-series-d .ct-line { stroke:#888888; }
.ct-series-d .ct-area { fill:  #888888; fill-opacity: 0.2; }
.ct-series-e .ct-line { stroke:#888888; }
.ct-series-e .ct-area { fill:  #888888; fill-opacity: 0.2; }
.ct-series-f .ct-line { stroke:#FFFFFF; }
span.ct-label.ct-vertical.ct-start { position: relative; top: 4px; }

</style>

<script type="text/javascript">

var last_msg_time = 0;
function handleMsgLogs(obj)
{
    var buff = [];
    var i;
    for (i = 0; i < 10; i++)
    {
        var istr = i.toString();
        if ((('msg_tick_' + istr) in obj) && (('msg_tick_' + istr) in obj) && (('msg_str_' + istr) in obj))
        {
            var itm = {};
            itm["tick"] = obj["msg_tick_" + istr];
            itm["time"] = obj["msg_time_" + istr];
            itm["str"]  = obj["msg_str_"  + istr];
            buff.push(itm);
        }
    }
    buff.sort(function(a, b) {
        return a["tick"] - b["tick"];
    });
    for (i = 0; i < buff.length; i++)
    {
        var itm = buff[i];
        if (itm["time"] > last_msg_time) {
            last_msg_time = itm["time"];
            msglog_append("[" + fmtTime(epochToDate(itm["time"])) + "]: " + itm["str"].trim());
        }
    }
}

var last_pulselog_time = 0;
function handlePulseLogs(obj)
{
    var buff = [];
    var i;
    for (i = 0; i < 10; i++)
    {
        var istr = i.toString();
        if ((('pulse_time_' + istr) in obj) && (('pulse_ra_' + istr) in obj) && (('pulse_dec_' + istr) in obj) && (('pulse_sum_' + istr) in obj))
        {
            var itm = {};
            itm["time"] = obj["pulse_time_" + istr];
            itm["ra"]   = obj["pulse_ra_"   + istr];
            itm["dec"]  = obj["pulse_dec_"  + istr];
            itm["sum"]  = obj["pulse_sum_"  + istr];
            itm["shutter"] = obj["pulse_shutter_" + istr];
            buff.push(itm);
        }
    }
    buff.sort(function(a, b) {
        return a["time"] - b["time"];
    });
    for (i = 0; i < buff.length; i++)
    {
        var itm = buff[i];
        if (itm["time"] > last_pulselog_time) {
            last_pulselog_time = itm["time"];
            errgraph_push(itm["time"], itm["ra"], itm["dec"], itm["sum"], itm["shutter"]);
        }
    }
}

var calibration = {"ra": null, "dec": null};
function handleCalibration(obj, axis)
{
    var inner = obj["calib_" + axis];
    var ele = document.getElementById("calibinfo_" + axis);
    if (inner == null || inner == false)
    {
        calibration[axis] = null;
        ele.innerHTML = "None";
        return;
    }

    calibration[axis] = inner;

    var txt = "";

    if (inner["success"] == false)
    {
        txt += "Calibration has failed.<br />";
    }

    var t = epochToDate(inner["time"]);
    txt += "Time: " + fmtDate(t) + " " + fmtTime(t) + "<br />";
    txt += "Pixels-per-ms = " + inner["pix_per_ms"].toFixed(1) + "<br />";
    txt += "Angle = " + inner["angle"].toFixed(1) + "&deg;<br />";
    if (("points_cnt" in inner) != false) {
        txt += "Points Used: " + inner["points_cnt"].toString() + "<br />";
    }
    txt += "Starting Coordinates: ( " + inner["start_x"].toFixed(1) + " , " + inner["start_y"].toFixed(1) + " )";
    ele.innerHTML = txt;
}

var settings = {};

function queueSettingsUpdate(key, val)
{
    settings[key] = val;
}

function onLoadAll()
{
    document.getElementById("loading").style.display = "none";

    document.getElementById("showme").style.display = "block";

    $( "#accordion" ).accordion({heightStyle: "content"});

    make_ui_intervalometer();
    make_ui_guidecamconfig();
    make_ui_mountconfig();
    make_ui_calibration();
    make_ui_analysisparameters();
    make_ui_console();

    $(window).on('resize', function(e) {
        needUiRefresh = true;
        errgraph_onresize();
    });

    websocket_init("websocket");
    document.getElementById("loading_connecting").style.display = "block";
}

function websock_onerror(evt)
{
    msglog_appendLocal("WEBSOCK ERR: " + evt.message);
    websocket_init("websocket");
    document.getElementById("connection_lost").style.display = "block";
}

function websock_onopen(evt)
{
    document.getElementById("connection_lost").style.display = "none";
    msglog_appendLocal("websocket opened!");
    if (websock_retransmit() == false)
    {
        miscCmd("getsettings");
        document.getElementById("loading").style.display = "none";
        document.getElementById("loading_connecting").style.display = "none";
        document.getElementById("loading_settings").style.display = "block";
    }
}

function websock_onmessage_jsonobj(obj)
{
    document.getElementById("connection_lost").style.display = "none";
    if (obj["pkt_type"] == "settings")
    {
        document.getElementById("loading_settings").style.display = "none";
        document.getElementById("loading_almost").style.display = "block";
        autoFillSettingsUi(obj);
    }
    else if (obj["pkt_type"] == "status")
    {
        document.getElementById("loading_almost").style.display = "none";
        handleCalibration(obj, "ra");
        handleCalibration(obj, "dec");
        handleMsgLogs(obj);
        handlePulseLogs(obj);
        imageStatsUpdate(obj);
        hotpixelsInfoUpdate(obj);
        if (("interval_state" in obj) && ("blub_remaining" in obj)) {
            intervalometerUpdate(obj["interval_state"], obj["blub_remaining"]);
        }
        else {
            console.log("intervalometer data missing from status"
        }
    }
}

function autoFillSettingsUi(obj)
{
    for (let key in obj) {
        if ((key in autopopulate_func_list) != false) {
            autopopulate_func_list[key](obj[key]);
        }
    }
}

function miscCmd(x)
{
    var obj = {}
    obj["pkt_type"] = "misc_cmd";
    obj["time"]     = time_getNowEpoch();
    obj["cmd"]      = x;
    if (socket != null) {
        socket.send(obj);
    }
    else {
        msglog_appendLocal("WEBSOCK ERR: no socket to send misc. cmd. with");
    }
}

function guideCmd(x)
{
    var obj = {}
    obj["pkt_type"] = "guide_cmd";
    obj["time"]     = time_getNowEpoch();
    obj["cmd"]      = x;
    if (socket != null) {
        socket.send(obj);
    }
    else {
        msglog_appendLocal("WEBSOCK ERR: no socket to send guide cmd. with");
    }
}

function selectStar(x, y)
{
    var obj = {}
    obj["pkt_type"] = "select_star";
    obj["time"]     = time_getNowEpoch();
    obj["cmd"]      = x;
    if (socket != null) {
        socket.send(obj);
    }
    else {
        msglog_appendLocal("WEBSOCK ERR: no socket to send select-star cmd. with");
    }
}

</script>

</head>
<body onload="onLoadAll();">
<div id="loading"><h2>OpenMV AutoGuider</h2><br /><h2>Loading, Please Wait! <span id="load_tries"></span></h2></div>
<div id="loading_failed" style="display:none;"><h1>Loading FAILED! Please refresh the page.</h1></div>
<div id="loading_connecting" style="display:none;"><h2>OpenMV AutoGuider</h2><br /><h2>Connecting to guide-cam...</h2></div>
<div id="loading_settings" style="display:none;"><h2>OpenMV AutoGuider</h2><br /><h2>Fetching settings...</h2></div>
<div id="loading_almost" style="display:none;"><h2>OpenMV AutoGuider</h2><br /><h2>Connected and settings loaded! Waiting for status data...</h2></div>
<div id="showme" style="display:none;">

<div style="width:100%"><fieldset style="padding-top: 1em;"><legend>OpenMV AutoGuider</legend><div id="viewme" style="display: inline-block; width:100%; padding: 0 0 0 0; margin: 0 0 0 0;"><div id="viewmejpeg" style="position: relative; z-index: 1"></div><div id="viewmesvg" style="position: relative; z-index: 2; top: 0; left: 0;">&nbsp;&nbsp;Please wait for image...</div>
</div></fieldset></div>

<div id="div_errgraph"><fieldset><legend>Error Graph</legend><div id="errgraph-chart" class="ct-graph ct-major-eleventh"><div style="text-align:right;position:relative;top:-3px;"><span style="color:#FF4444"><b>&mdash;</b>&nbsp;RA&nbsp;<span>&nbsp;&nbsp;<span style="color:#4488FF">&nbsp;<b>&mdash;</b>&nbsp;DEC<span></div></fieldset></div>

<div id="connection_lost" class="ui-widget" style="display: none;"><div id="connection_lost_inner" class="hideable-msg ui-state-error ui-corner-all .ui-state-error-text" ><p>Connection LOST! Attempting to re-establish...</p></div></div>
<div id="memory_error" class="ui-widget" style="display: none;"><div id="memory_error_inner" class="hideable-msg ui-state-error ui-corner-all .ui-state-error-text" ><p>INTERNAL MEMORY ERROR! Please check the camera exposure settings!</p></div></div>
<div id="camera_hardware_error" class="ui-widget" style="display: none;"><div id="camera_hardware_error_inner" class="hideable-msg ui-state-error ui-corner-all .ui-state-error-text" ><p>CAMERA HARDWARE ERROR! Please check the camera exposure settings.<br />Lower the shutter time.<br />Do a full power-off-power-on reset if the problem is not solved.</p></div></div>
<div id="mount_hardware_error" class="ui-widget" style="display: none;"><div id="mount_hardware_error_inner" class="hideable-msg ui-state-error ui-corner-all .ui-state-error-text" ><p>MOUNT HARDWARE ERROR!<br />Do a full power-off-power-on reset if the problem is not solved.</p></div></div>
<div id="camera_hardware_wait" class="ui-widget" style="display: none;"><div id="camera_hardware_wait_inner" class="hideable-msg ui-state-error ui-corner-all .ui-state-error-text" ><p>WAITING for camera to load new exposure settings...</p></div></div>

<div id="div_starprofile" style="display:none;"><fieldset><legend>Star Profile</legend><div id="starprofile_div"></div></fieldset></div>



<div id="accordion">
  <h3>Intervalometer</h3>
  <div>
    <script type="text/javascript">

var bulb_times_lut = [1, 5, 10, 15, 20, 25, 30, 45, 60, 75, 90, 105, 120, 150, 180, 210, 240, 270, (60 * 5), (60 * 6), (60 * 7), (60 * 8), (60 * 9), (60 * 10), (60 * 12), (60 * 14), (60 * 16)];

function make_ui_intervalometer()
{
    makeButton("btn_interval_loop", function( event ) {
        ui_list["btn_interval_stopnext"].button("option", "disabled", false);
        ui_list["btn_interval_stopnow"] .button("option", "disabled", false);
        ui_list["btn_interval_single"]  .button("option", "disabled", true);
        ui_list["btn_interval_loop"]    .button("option", "disabled", true);
        intervalometerCmd(1);
    });
    makeButton("btn_interval_single", function( event ) {
        ui_list["btn_interval_stopnext"].button("option", "disabled", true);
        ui_list["btn_interval_stopnow"] .button("option", "disabled", false);
        ui_list["btn_interval_single"]  .button("option", "disabled", false);
        ui_list["btn_interval_loop"]    .button("option", "disabled", false);
        intervalometerCmd(3);
    });
    makeButton("btn_interval_stopnext", function( event ) {
        ui_list["btn_interval_stopnext"].button("option", "disabled", true);
        ui_list["btn_interval_stopnow"] .button("option", "disabled", false);
        ui_list["btn_interval_single"]  .button("option", "disabled", true);
        ui_list["btn_interval_loop"]    .button("option", "disabled", true);
        intervalometerCmd(5);
    });
    makeButton("btn_interval_stopnow", function( event ) {
        ui_list["btn_interval_stopnext"].button("option", "disabled", true);
        ui_list["btn_interval_stopnow"] .button("option", "disabled", true);
        ui_list["btn_interval_single"]  .button("option", "disabled", false);
        ui_list["btn_interval_loop"]    .button("option", "disabled", false);
        intervalometerCmd(4);
    });
    makeSliderLookup("slider_bulbtime", 6, bulb_times_lut, function(v) {
            queueSettingsUpdate("intervalometer_bulb_time", v);
        }
    );
    makeSlider("slider_ditherinterval", 1, 100, 1, 1, "0", "", function(v) {
        queueSettingsUpdate("dither_interval", v);
    });
    makeSlider("slider_ditherlimit", 0, 500, 0, 1, "OFF", " pix", function(v) {
        queueSettingsUpdate("dither_amount", v);
    });
    makeSlider("slider_dithersettlethresh", 0, 10, 3, 1, "0 pix", " pix", function(v) {
        queueSettingsUpdate("dither_calmness", v);
    });
    makeSlider("slider_dithersettleframecnt", 1, 10, 3, 1, "0 frames", " frames", function(v) {
        queueSettingsUpdate("dither_calm_cnt", v);
    });
    makeSlider("slider_dithertimeout", 1, 10, 5, 1, "0 frames", " frames", function(v) {
        queueSettingsUpdate("dither_frames_cnt", v);
    });

    // TODO: digital intervalometer mode
}

var intervalometer_status = 0;
var intervalometer_remaining = 0;
var intervalometer_timer = null;
var intervalometer_gotoidletimer = null;
function intervalometerUpdate(status, remain)
{
    intervalometer_status = status;
    if (intervalometer_remaining <= 0) {
        intervalometer_remaining = remain;
        if (remain > 0 && intervalometer_timer == null) {
            intervalometer_timer = setTimeout(intervalometerCountDown, 100);
        }
    }
    else if (remain <= 0) {
        intervalometer_remaining = 0;
    }
    else if (intervalometer_remaining > remain) {
        intervalometer_remaining = remain;
    }
    intervalometerShow();
}

function intervalometerShow()
{
    var ele = document.getElementById("bulb_status");

    var timetxt = (Math.round(intervalometer_remaining/100.0)/10.0).toFixed(1) + " sec Remaining";

    if (intervalometer_status == 0)
    {
        ele.innerHTML = "IDLE";
        ui_list["btn_interval_stopnext"].button("option", "disabled", true);
        ui_list["btn_interval_stopnow"] .button("option", "disabled", true);
        ui_list["btn_interval_single"]  .button("option", "disabled", false);
        ui_list["btn_interval_loop"]    .button("option", "disabled", false);
        if (intervalometer_gotoidletimer != null) {
            clearTimeout(intervalometer_gotoidletimer);
            intervalometer_gotoidletimer = null;
        }
    }
    else if (intervalometer_status == 1 || intervalometer_status == 2)
    {
        ele.innerHTML = "Looping: " + timetxt;
        ui_list["btn_interval_stopnext"].button("option", "disabled", false);
        ui_list["btn_interval_stopnow"] .button("option", "disabled", false);
        ui_list["btn_interval_single"]  .button("option", "disabled", true);
        ui_list["btn_interval_loop"]    .button("option", "disabled", true);
    }
    else if (intervalometer_status == 3)
    {
        ele.innerHTML = "Single-Shot: " + timetxt;
        if (intervalometer_remaining > 0)
        {
            ui_list["btn_interval_stopnext"].button("option", "disabled", true);
            ui_list["btn_interval_stopnow"] .button("option", "disabled", false);
            ui_list["btn_interval_single"]  .button("option", "disabled", true);
            ui_list["btn_interval_loop"]    .button("option", "disabled", false);
        }
        else
        {
            ui_list["btn_interval_stopnext"].button("option", "disabled", true);
            ui_list["btn_interval_stopnow"] .button("option", "disabled", true);
            ui_list["btn_interval_single"]  .button("option", "disabled", true);
            ui_list["btn_interval_loop"]    .button("option", "disabled", false);
            if (intervalometer_gotoidletimer == null) {
                intervalometer_gotoidletimer = setTimeout(function() {
                    intervalometerUpdate(0, 0);
                }, 1000);
            }
        }
    }
    else if (intervalometer_status == 4)
    {
        ele.innerHTML = "Stopping Now";
        ui_list["btn_interval_stopnext"].button("option", "disabled", true);
        ui_list["btn_interval_stopnow"] .button("option", "disabled", true);
        ui_list["btn_interval_single"]  .button("option", "disabled", true);
        ui_list["btn_interval_loop"]    .button("option", "disabled", true);
        if (intervalometer_gotoidletimer == null) {
            intervalometer_gotoidletimer = setTimeout(function() {
                intervalometerUpdate(0, 0);
            }, 1000);
        }
    }
    else if (intervalometer_status == 5)
    {
        ele.innerHTML = "Stopping On Next, " + timetxt;
        ui_list["btn_interval_stopnext"].button("option", "disabled", true);
        ui_list["btn_interval_stopnow"] .button("option", "disabled", false);
        ui_list["btn_interval_single"]  .button("option", "disabled", true);
        ui_list["btn_interval_loop"]    .button("option", "disabled", false);
    }
}

function intervalometerCountDown()
{
    if (intervalometer_remaining > 100) {
        intervalometer_remaining -= 100;
    }
    else {
        intervalometer_remaining = 0;
    }
    intervalometerShow();
    intervalometer_timer = setTimeout(intervalometerCountDown, 100);
}

function intervalometerCmd(cmd)
{
    intervalometerUpdate(cmd, settings["intervalometer_bulb_time"] * 1000);
    var obj = {}
    obj["pkt_type"] = "intervalometer_cmd";
    obj["time"]     = time_getNowEpoch();
    obj["cmd"]      = x;
    if (socket != null) {
        socket.send(obj);
    }
    else {
        msglog_appendLocal("WEBSOCK ERR: no socket to send intervalometer cmd. with");
    }
}
    </script>
    <p><button id="btn_interval_loop">Loop</button>&nbsp;<button id="btn_interval_single">Single</button>&nbsp;<button id="btn_interval_stopnext">Stop On Next</button>&nbsp;<button id="btn_interval_stopnow">Stop Now</button></p>
    <div><fieldset><legend>Status</legend>
        <div id="bulb_status" style="font-size:20pt;">0</div>
    </fieldset></div>
    <div><fieldset><legend>Bulb Time: <span id="slider_bulbtime_handle"></span> sec</legend>
        <div id="slider_bulbtime"></div>
    </fieldset></div>
    <br />
    <div><fieldset><legend>Dither Dist. (0 to disable dithering): <span id="slider_ditherlimit_handle"></span></legend>
        <div id="slider_ditherlimit"></div>
    </fieldset></div>
    <div><fieldset><legend>Dither Inverval: Every <span id="slider_ditherinterval_handle">x</span> Frames</legend>
        <div id="slider_ditherinterval"></div>
    </fieldset></div>
    <div><fieldset><legend>Dither Settle Thresh: <span id="slider_dithersettlethresh_handle"></span></legend>
        <div id="slider_dithersettlethresh"></div>
    </fieldset></div>
    <div><fieldset><legend>Dither Settle Frame Count: <span id="slider_dithersettleframecnt_handle"></span></legend>
        <div id="slider_dithersettleframecnt"></div>
    </fieldset></div>
    <div><fieldset><legend>Dither Timeout Frame Count: <span id="slider_dithertimeout_handle"></span></legend>
        <div id="slider_dithertimeout"></div>
    </fieldset></div>
    <!-- TODO: digital intervalometer mode --><br />
    <br />
    <div><fieldset><legend>Help</legend><p>
        <p>This auto-guider features an intervalometer that can control the shutter of a camera. The camera must be set in <b>bulb</b> mode for this to work.</p>
        <p><b>Loop</b> operation of the intervalometer will make the camera take pictures repeatedly, each one with the exposure time as set by the "<b>Bulb Time</b>" option.</p>
        <p><b>Single</b> shot operation will take one photo at with the bulb-time exposure. Use this to get a preview photo.</p>
        <p>"<b>Stop On Next</b>" will end the loop mode of the intervalometer, so that the next photo can be previewed. Use this feature if you need to adjust camera focus (or a similar task that requires pausing and reviewing) during the session.</p>
        <p>"<b>Stop Now</b>" will immediately close the camera shutter and end the loop mode of the intervalometer. This will probably ruin the last photo being captured. Use this if you are impatient and need to change settings.</p>
    </p></fieldset></div>
    <br />
    <div><fieldset><legend>Dithering Help</legend><p>
        <p><b>Dithering</b> is a technique that reduces apparant noise in stacked photographs. If a camera is extra noisy in one spot, or has a hot-pixel, and consecutive photos from that camera are stacked together, then the noise or hot-pixel will appear in the final stacked photograph. This is because the rejection algorithms in the stacking software can reject things that sporatically appear, but not things that are always there. In layman's terms, the algorithm thinks that things that are "always there" should be there.</p>
        <p>Dithering means that for each photo, the camera is moved around slightly. This way, even though a bad pixel is staying at the same coordinate on the image, it <b>does not stay</b> at the same spot in the sky. This will make the stacking software reject the bad pixel. This also helps reduce patterned noise because it smears the noise around, while preserving signal details.</p>
        <p>Enabling dithering means that when the shutter is closed, the tracking telescope mount will be given a command to randomly move around a bit. This amount is set by the "<b>Dither Distance</b>" value. The original center position of your photo will be rembered and it won't drift more than the distance set. <b>If this value is 0, then dithering will be disabled</b>. If this value is too high, then the final stacked photo will have a smaller usable region. Also, it takes more time for the dithering operation to complete if the distance is too long.</p>
        <p>After performing each dither movement, there is extra risk of tracking errors due to gear backlash, vibration, and other factors. The firmware will wait for things to settle down before allowing the intervalometer to re-open the camera shutter. This will prevent unwanted star-trailing in the next photo after a dithering movement.</p>
        <p>The "<b>Dither Settle Thresh</b>" is the maximum amount of star motion detected so that the mount is considered "settled", if the star moves more than this amount, then the mount is not considered "settled". "<b>Dither Settle Frame Count</b>" is the number of consecutive guide-cam frames that need to be considered settled before opening the photo-cam's shutter again. "<b>Dither Timeout Frame Count</b>" is the maximum number of guide-cam frames to wait for settling, whether or not, after this timeout, the photo-cam's shutter will open.</p>
        <p>Since dithering takes time, you can choose to only dither after a certain number of frames.</p>
    </p></fieldset></div>
  </div>
  <h3>Guide-Cam Config</h3>
  <div>
    <script type="text/javascript">

function make_ui_guidecamconfig()
{
    $("#btn_streamimg" ).button().click(function( event ) {
        console.log("click btn_streamimg");
        window.location.href = "/stream";
    });
    $("#btn_streamimg_star" ).button().click(function( event ) {
        console.log("click btn_streamimg_star");
        window.location.href = "/stream?zoom";
    });

    makeSlider("slider_gain"              , 0, 128, 32, 8, "0 dB", " dB",     "gain");
    makeSlider("slider_shutter"           , 100, 3000, 1000, 100, "0", " ms", "shutter");
    makeSlider("slider_starthresh"        , 0, 255, 0, 1, "auto", "/255",     "thresh");
    makeSlider("slider_imgerrpanicthresh" , 1, 100, 3, 1, "0", "",            "panicthresh_expoerr");
}

function imageStatsUpdate(obj)
{
    var ele = document.getElementById("div_histogram");
    var stats_str = "";
    if (obj !== undefined && typeof obj !== 'undefined') {
        stats_str = "no data available";
        ele.innerHTML = stats_str;
        return;
    }
    else if (('img' in obj) == false)
    {
        stats_str = "no image data    \t";
    }
    else if (obj["img"] == false || obj["img"] == null)
    {
        stats_str = "no image captured    \t";
    }
    else
    {
        stats_str = "num of stars: " + star_cnt.toString() + "&nbsp;&nbsp;&nbsp;&nbsp;";
        stats_str += "image mean: "  + math_roundPlaces(obj["img_mean"], 1).toString() + "/255    \t";
        stats_str += "image stdev: " + math_roundPlaces(obj["img_stdev"], 1).toString() + "/255    \t";
        stats_str += "image max: " + Math.round(obj["img_max"]).toString() + "/255    \t";
        stats_str += "image min: " + Math.round(obj["img_min"]).toString() + "/255    \t";
    }

    stats_str += "exposure code: ";

    if (('expo_code' in obj) == false)
    {
        stats_str += "missing code";
    }
    else
    {
        var exposure_code = obj["expo_code"];
        var exposure_code_txt = getExposureCode(exposure_code);
        stats_str += exposure_code_txt;

        if (exposure_code == 6) {
            document.getElementById("memory_error").style.display = "block";
        }
        else {
            document.getElementById("memory_error").style.display = "none";
        }

        if (exposure_code == 7) {
            document.getElementById("camera_hardware_error").style.display = "block";
        }
        else {
            document.getElementById("camera_hardware_error").style.display = "none";
        }

        if (exposure_code == 8) {
            document.getElementById("camera_hardware_wait").style.display = "block";
        }
        else {
            document.getElementById("camera_hardware_wait").style.display = "none";
        }
    }

    while (stats_str.includes(" ")) {
        stats_str = stats_str.replace(" ", "&nbsp;");
    }
    ele.innerHTML = stats_str;
}

    </script>
    <div><button id="btn_streamimg">Stream Image Full Screen</button><button id="btn_streamimg_star">Stream Image of Selected Star</button></div><br />
    <div><fieldset><legend>Image Statistics</legend>
    <div id="div_histogram"></div>
    </fieldset></div>
    <div><fieldset><legend>Camera Gain: <span id="slider_gain_handle"></span></legend>
        <div id="slider_gain"></div>
    </fieldset></div>
    <div><fieldset><legend>Shutter: <span id="slider_shutter_handle"></span></legend>
        <div id="slider_shutter"></div>
    </fieldset></div>
    <div><fieldset><legend>Star Threshold: <span id="slider_starthresh_handle"></span></legend>
        <div id="slider_starthresh"></div>
    </fieldset></div>
    <div><fieldset><legend>Image Error Panic Threshold: <span id="slider_imgerrpanicthresh_handle"></span></legend>
        <div id="slider_imgerrpanicthresh"></div>
    </fieldset></div>
    <br />
    <div><fieldset><legend>Help</legend><p>
        <p>The "<b>Camera Gain</b>" is basically the ISO of the camera sensor. Increasing the gain will increase the overall brightness of the image, with stars easier to see. But a higher gain will mean more noise as well. Very high gain levels may cause hot-pixels to appear.</p>
        <p>The <b>shutter</b> time of the guide-cam can be adjusted. The a longer value will allow in more light, causing a brighter image and making dark stars easier to detect. But don't make the shutter time too long, because corrective movements should only be made while the guide-cam is not taking a picture, otherwise the stars will trail and cannot be analyzed.</p>
        <p>The "<b>Star Threshold</b>" is the brightness value of a pixel for it to be considered a star. If this value is left at zero, then the threshold will be automatically determined by the overall brightness of the image. A very high threshold value will cause darker stars to be ignored.</p>
        <p>The "<b>Image Error Panic Threshold</b>" is the number of frames with a bad image (some form of camera malfunction, or a search helicopter is putting a spotlight on your telescope) before the auto-guider gives up and quits guiding. The red LED light will blink to notify you.</p>
        <p>The image from the guide-cam can be streamed. Use this stream to adjust the focus of your guide-scope. Since the file transfer speed is slow, guiding is not possible during the stream.</p>
    </p></fieldset></div>
  </div>
  <h3>Mount Config</h3>
  <div>
    <script type="text/javascript">
function make_ui_mountconfig()
{
    makeSlider("slider_pulse_minimum", 10, 500, 50, 1, "0 ms", " ms", "min_pulse_wid");
    makeSlider("slider_pulse_maximum", 0, 3000, 900, 100, "auto", " ms", "max_pulse_wid");
    makeSlider("slider_pulse_calistep", 100, 5000, 900, 100, "0 ms", " ms", "calibration_pulse", "slider_pulse_calistep2");
    makeSlider("slider_pulse_settle", 0, 500, 50, 1, "0 ms", " ms", "move_grace");
    makeSlider("slider_dirchangehyster", 0, 5000, 500, 1, "0 ms", " ms", "backlash_hyster");
    makeSlider("slider_backlashlimit", 0, 10000, 5000, 100, "auto", " ms", "backlash_limit");
    makeCheckbox("chk_flip_ra" , false, "flip_ra" );
    makeCheckbox("chk_flip_dec", false, "flip_dec");
}
    </script>
    <div><fieldset><legend>Minimum Pulse: <span id="slider_pulse_minimum_handle"></span></legend>
        <div id="slider_pulse_minimum"></div>
    </fieldset></div>
    <div><fieldset><legend>Maximum Pulse: <span id="slider_pulse_maximum_handle"></span></legend>
        <div id="slider_pulse_maximum"></div>
    </fieldset></div>
    <div><fieldset><legend>Calibration Step Pulse: <span id="slider_pulse_calistep_handle"></span></legend>
        <div id="slider_pulse_calistep"></div>
    </fieldset></div>
    <div><fieldset><legend>Settle Time: <span id="slider_pulse_settle_handle"></span></legend>
        <div id="slider_pulse_settle"></div>
    </fieldset></div>
    <div><fieldset><legend>Direction Change Hysteresis: <span id="slider_dirchangehyster_handle"></span></legend>
        <div id="slider_dirchangehyster"></div>
    </fieldset></div>
    <div><fieldset><legend>Direction Bias Limiter: <span id="slider_backlashlimit_handle"></span></legend>
        <div id="slider_backlashlimit"></div>
    </fieldset></div>
    <br />
    <div><span><label for="chk_flip_ra">Flip RA?</label><input type="checkbox" name="chk_flip_ra" id="chk_flip_ra"></span>&nbsp;&nbsp;&nbsp;&nbsp;<span><label for="chk_flip_dec">Flip DEC?</label><input type="checkbox" name="chk_flip_dec" id="chk_flip_dec"></span></div>
    <br />
    <div><fieldset><legend>Help</legend><p>
        <p>This auto-guider camera uses ST-4 signals to control an electronic telescope mount. When the signal is "ON", the motors inside the mount will spin faster. How long a signal is ON for, the length of the <b>pulse</b>, determines how much the mount moves. If the pulse is too short, the electronics might not detect it. If the pulse is too long, then the motion analysis need to happen much later, so the responsiveness is worse.</p>
        <p>The pulses used for each calibration step can be much longer, and a longer pulse can mean a more accurate calibration.</p>
        <p>"<b>Settle Time</b>" is the time that the signal is OFF for after each ON pulse. This can be very short, or even zero.</p>
        <p>Tracking errors of an electronic mount usually are biased in one direction. These mounts also have some backlash in their gears. This means that changing the direction of consecutive corrective movements is a bad idea as it can become ineffective, or over-correct. The corrective-movement-calculation firmware will track the direction bias, and if it detects a bias, it will lock-in a direction, preventing movements in the other direction. The "<b>Direction Change Hysteresis</b>" value represents how easy it is to detect the bias, and also how easy it is to change that bias.</p>
        <p>For example, the hysteresis value is 100 ms, a star moved and required a 100 ms movement to the right, the firmware will remember that the bias is towards the right. Then, if the star moved and required a 50 ms move to the left, the command to move will not actually be given, because the bias is towards the right, and all left-ward commands will be ignored. But if the star moved and required 200 ms move to the left, then it will actually perform the 200 ms move to the left, because with 200 ms, it has crossed the direction change hysteresis value.</p>
        <p>This technique helps the most with "momentary movements that naturally returns to original position", such as movement caused by wind. These types of moments shouldn't require correction, as the risk of (and penalty for) over-correction is high. It is similar to the "<b>ResistSwitch</b>" algorithm present in PHD2.</p>
        <p>"<b>Direction Bias Limiter</b>" is an internal maximum limit value for the accumulated value that determines the direction bias. Leave it at zero for it to be automatic. A large value will cause direction bias to never switch directions! The appropriate hysteresis value and limit value are different for every tracking telescope mount. More backlash requires higher values.</p>
    </p></fieldset></div>
  </div>
  <h3>Calibration</h3>
  <div>
    <script type="text/javascript">
function make_ui_calibration()
{
    makeSlider("slider_pulse_calistep2", 100, 5000, 900, 100, "0 ms", " ms", "calibration_pulse", "slider_pulse_calistep");
    makeSlider("slider_calistepcnt", 1, 50, 10, 1, "0", "", "calib_points_cnt");
    makeSlider("slider_correctionscale_ra", 75, 133, 100, 1, "0 %", " %", "correction_scale_ra");
    makeSlider("slider_correctionscale_dec", 75, 133, 100, 1, "0 %", " %", "correction_scale_dec");
    makeButton("btn_calib_ra", function() {
        guideCmd(4); // GUIDESTATE_CALIBRATING_RA
        document.getElementById("calibinfo_ra").innerHTML = "Running Calibration...";
    });
    makeButton("btn_calib_dec", function() {
        guideCmd(5); // GUIDESTATE_CALIBRATING_DEC
        document.getElementById("calibinfo_dec").innerHTML = "Running Calibration...";
    });
    makeButton("btn_calib_save", function() {
        miscCmd("calib_save");
    });
    makeButton("btn_calib_load", function() {
        miscCmd("calib_load");
        document.getElementById("calibinfo_ra") .innerHTML = "Loading...";
        document.getElementById("calibinfo_dec").innerHTML = "Loading...";
    });
    makeButton("btn_calib_remove_ra", function() {
        miscCmd("calib_reset_ra");
        document.getElementById("calibinfo_ra").innerHTML = "None";
    });
    makeButton("btn_calib_remove_dec", function() {
        miscCmd("calib_reset_dec");
        document.getElementById("calibinfo_dec").innerHTML = "None";
    });
}
    </script>
    <p>Calibration is required before auto-guiding. It correlates how much a star mas moved in the guide-cam image, to how long of a movement command pulse needs to be. It also determines the angular orientation of the guide-camera.</p>
    <div><fieldset><legend>Calibration Step Pulse: <span id="slider_pulse_calistep2_handle"></span></legend>
        <div id="slider_pulse_calistep2"></div>
    </fieldset></div>
    <div><fieldset><legend>Calibration Step Count: <span id="slider_calistepcnt_handle"></span></legend>
        <div id="slider_calistepcnt"></div>
    </fieldset></div>
    <div><fieldset><legend>Correction Scale R.A.: <span id="slider_correctionscale_ra_handle"></span></legend>
        <div id="slider_correctionscale_ra"></div>
    </fieldset></div>
        <div><fieldset><legend>Correction Scale Dec.: <span id="slider_correctionscale_dec_handle"></span></legend>
        <div id="slider_correctionscale_dec"></div>
    </fieldset></div>
    <br />
    <button id="btn_calib_save">Save File</button>&nbsp;<button id="btn_calib_load">Load File</button>
    <br />
    <br />
    <div><fieldset><legend>R.A. Calibration</legend>
        <div><button id="btn_calib_ra">Run Calibration</button>&nbsp;&nbsp;<button id="btn_calib_remove_ra">Remove</button></div>
        <br />
        <div id="calibinfo_ra">None</div>
    </fieldset></div>
    <div><fieldset><legend>Dec. Calibration</legend>
        <div><button id="btn_calib_dec">Run Calibration</button>&nbsp;&nbsp;<button id="btn_calib_remove_dec">Remove</button></div>
        <br />
        <div id="calibinfo_dec">None</div>
    </fieldset></div>
    <br />
    <div><fieldset><legend>Help</legend><p>
        <p>During calibration, a star will be tracked and movement command pulses will be given to the tracking telescope mount. If the pulse given is 1000 ms long, and the star moved 10 pixels in the guide-cam image, then the scaling is remembered as 100 ms-per-pixel, or as 0.01 pixels-per-ms. The direction of the movement is also remembed.</p>
        <p>This is done many times (number of steps) to get an accurate average value. It is also done in both the <b>R</b>ight-<b>A</b>scension axis and <b>Dec</b>lination axis independantly.</p>
        <p>If you are using a R.A.-only type of tracking mount, such as the Star Adventurer or Sky Guider, then only the R.A. calibration is required. If you are using a computerized go-to type of telescope mount, then both R.A. and declination calibration are required.</p>
        <p>Calibration needs to be done any time your camera is pointed in a different direction! This usually means once per night!</p>
        <p>Calibration can be saved, with a timestamp, so they can be reloaded. This is useful in the event of a brief power failure.</p>
        <p>The "<b>Correction Scale</b>" value will scale the ms-per-pixel that is actually used to make corrective movements. Lower this value below 100% to combat cronic over-correction.</p>
        <p>NOTE: This auto-guider firmware does not care about things such as focal length of the lens or the speed of the tracking mount motors when given a pulse. Everything is simply based on the number of pixels that a star moves on the guide-cam, and the duration of the pulses. The units cannot be correlated directly to angular units (aka degrees).</p>
    </p>
    </fieldset></div>
  </div>
  <h3>Analysis Parameters</h3>
  <div>
    <script type="text/javascript">
function make_ui_analysisparameters()
{
    makeSlider("slider_multistar", 1, 100, 1, 1, "0", "", "multistar_cnt_max");
    makeSlider("slider_motionerrortolerance", 1, 200, 50, 1, "0 pix", " pix", "starmove_tolerance");
    makeSlider("slider_motionerrorpanicthresh", 0, 500, 50, 1, "0 pix", " pix", "panicthresh_move_err");
    makeSlider("slider_motionerrorcountpanicthresh", 1, 100, 2, 1, "0", "", "panicthresh_move_cnt");
    makeSlider("slider_multistarratingthresh", 0, 100, 50, 1, "0 %", " %", "multistar_ratings_thresh");
    makeSlider("slider_clustertolerance", 0, 500, 100, 1, "0 pix", " pix", "clustering_tolerance");
}
    </script>
    <p>These parameters are used to fine tune the star motion analysis software.</p>
    <div><fieldset><legend>Stars Used: <span id="slider_multistar_handle"></span></legend>
        <div id="slider_multistar"></div>
    </fieldset></div>
    <div><fieldset><legend>Motion Error Tolerance: <span id="slider_motionerrortolerance_handle"></span></legend>
        <div id="slider_motionerrortolerance"></div>
    </fieldset></div>
    <div><fieldset><legend>Motion Error Amount Panic Thresh: <span id="slider_motionerrorpanicthresh_handle"></span></legend>
        <div id="slider_motionerrorpanicthresh"></div>
    </fieldset></div>
    <div><fieldset><legend>Motion Error Count Panic Thresh: <span id="slider_motionerrorcountpanicthresh_handle"></span></legend>
        <div id="slider_motionerrorcountpanicthresh"></div>
    </fieldset></div>
    <div><fieldset><legend>Multi-Star Rating Thresh: <span id="slider_multistarratingthresh_handle"></span></legend>
        <div id="slider_multistarratingthresh"></div>
    </fieldset></div>
    <div><fieldset><legend>Cluster Tolerance: <span id="slider_clustertolerance_handle"></span></legend>
        <div id="slider_clustertolerance"></div>
    </fieldset></div>
    <div><fieldset><legend>Help</legend><p>
        <p>The number of stars used for motion analysis can be 1 or more. Usage of multiple stars is advised to combat the effects of turbulent air in the atmosphere (aka <i>atmospheric seeing</i> or <i>astronomical seeing</i>). The motion of multiple stars can be averaged together, instead of analyzing just one star, in order to prevent detection of motion that didn't really occur.</p>
        <p>When multiple stars are used for motion analysis, the best stars, ranked by its "<i>rating</i>", are used. The "<b>Multi-Star Rating Thresh</b>" is the minimum rating a star needs to have for it to be used in the analysis. A good rating means the star can be accurately confidently tracked and is not too close to the edge of the guide-cam frame.</p>
        <p>"<b>Motion Error</b>" is measured in pixels. If all of the stars moved 5 pixels to the left, then the motion error is considered 0. If one star moved 5 pixels left but another star moved 5 pixels right, then the motion error is considered to be 10 pixels. A high amount of motion analysis error is unlikely in most scenarios but you can set thresholds for the error to cause panic mode.</p>
        <p>"<b>Motion Error Tolerance</b>" is the amount of motion error tolerated by the analysis code, it will simply not analyze stars that moved more than this amount in the wrong direction.</p>
        <p>"<b>Motion Error Amount Panic Thresh</b>" is the average amount of motion error in the motion analysis that will trigger one frame to be considered a panic-inducing frame.</p>
        <p>"<b>Motion Error Count Panic Thresh</b>" is the number of consecutive panic-inducing frames that needs to happen before the hardware gives up and starts to blink the red LED light. This setting can be 1, or it can be more, so that maybe a single bat flying over your camera doesn't cause the hardware to throw in the towel. Long periods of cloudy sky, or knocking over the telescope, will cause many panic-inducing frames and you will see the blinking red LED light.</p>
        <p>When too many stars are very close together, it might confuse the motion analysis software. "<b>Cluster Tolerance</b>" determines how far apart a star need to be away from its nearest neighbouring star for it to be used for motion analysis.</p>
    </p></fieldset></div>
  </div>
  <h3>Hot Pixels</h3>
  <div>
    <script type="text/javascript">
function make_ui_hotpixels()
{
    makeButton("btn_hotpixels", function() {
        miscCmd("hotpixels_save");
        ui_list["btn_hotpixels"]      .button("option", "disabled", true);
    });
    makeButton("btn_forgethotpixels", function() {
        miscCmd("hotpixels_disable");
        ui_list["btn_forgethotpixels"].button("option", "disabled", true);
    });
    makeButton("btn_loadhotpixels", function() {
        miscCmd("hotpixels_load");
    });
}

function hotpixelsInfoUpdate(obj)
{
    var ele = document.getElementById("hotpixel_info");
    if (obj !== undefined && typeof obj !== 'undefined') {
        ele.innerHTML = "no data available";
        ui_list["btn_hotpixels"]      .button("option", "disabled", false);
        ui_list["btn_forgethotpixels"].button("option", "disabled", true);
        ui_list["btn_loadhotpixels"]  .button("option", "disabled", false);
        return;
    }
    if (('hotpix' in obj) == false)
    {
        ele.innerHTML = "no hot-pixel info available";
        ui_list["btn_hotpixels"]      .button("option", "disabled", false);
        ui_list["btn_forgethotpixels"].button("option", "disabled", true);
        ui_list["btn_loadhotpixels"]  .button("option", "disabled", false);
        return;
    }
    if (obj["hotpix"] == false || obj["hotpix"] == null)
    {
        ele.innerHTML = "no hot-pixels";
        ui_list["btn_hotpixels"]      .button("option", "disabled", false);
        ui_list["btn_forgethotpixels"].button("option", "disabled", true);
        ui_list["btn_loadhotpixels"]  .button("option", "disabled", false);
        return;
    }
    var cnt = obj["hotpix_cnt"];
    if (obj["hotpix_used"] != false)
    {
        ele.innerHTML = cnt.toString() + " hot-pixels being used. Currently removing " + obj["hotpix_last"].toString() + " false stars.";
        ui_list["btn_hotpixels"]      .button("option", "disabled", true);
        ui_list["btn_forgethotpixels"].button("option", "disabled", false);
        ui_list["btn_loadhotpixels"]  .button("option", "disabled", true);
    }
    else
    {
        ele.innerHTML = cnt.toString() + " hot-pixels registered, but not being used.";
        ui_list["btn_hotpixels"]      .button("option", "disabled", false);
        ui_list["btn_forgethotpixels"].button("option", "disabled", true);
        ui_list["btn_loadhotpixels"]  .button("option", "disabled", false);
    }
}

    </script>
    <p>If the camera gets too hot, there will be pixels that appear to be stuck as white. These stuck pixels will be falsely detected as stars. You will notice these pixels when you see stars that do not move even though you are moving the camera around.</p>
    <p>It is possible to memorize which pixels are stuck so that they are removed from the list of stars. To do so: <ol><li>turn up the guide-cam gain and guide-cam shutter time slightly</li><li>cover up the guide-camera completely</li><li>click the "capture hot pixels" button</li><li>restore your original guide-cam settings</li></ol></p>
    <p>Think of this as taking a "dark frame" but not really the same thing.</p>
    <p><button id="btn_hotpixels">Capture Hot Pixels</button><button id="btn_forgethotpixels">Forget Hot Pixels</button><button id="btn_loadhotpixels">Load Hot Pixels File</button></p>
    <p><fieldset><legend>Hot Pixel Info</legend><div id="hotpixel_info"></div></fieldset></p>
  </div>
  <h3>Console</h3>
  <div>
    <script type="text/javascript">
function make_ui_console()
{
    makeButton("btn_consoleinput_send", function() {
        var txt = document.getElementById("txt_consoleinput").value.trim();
        console.log("text: " + txt);
        if (txt.length > 0)
        {
            ui_list["btn_consoleinput_send"].button("option", "disabled", true);
            setTimeout(function(){ ui_list["btn_consoleinput_send"].button("option", "disabled", false); }, 2000);
            msglog_append("> " + txt);
            miscCmd(txt);
        }
    });
    $("#txt_consoleinput").button().addClass('consoleinput-textfield');
    makeButton("btn_consoleclear", function() {
        document.getElementById("div_msglog").innerHTML = "messages cleared at " + new Date().toString();
    });
}

function msglog_append(txt)
{
    var ele = document.getElementById("div_msglog");
    var old = ele.innerHTML;
    ele.innerHTML = txt + "\r\n<br />\r\n" + old;
}

function msglog_appendLocal(txt)
{
    var ele = document.getElementById("div_msglog");
    var old = ele.innerHTML;
    ele.innerHTML = "[" + fmtTime(new Date()) + "]: " + txt + "\r\n<br />\r\n" + old;
}

    </script>
    <style type="text/css">
.consoleinput-textfield {
    width: 100%;
    font: inherit;
    font-family: monospace;
    color: #000;
    text-align: inherit;
    outline: none;
    cursor: text;
    background-color: #DDD;
}
    </style>
    <fieldset><legend>Input</legend><div><input type="text" id="txt_consoleinput" name="txt_consoleinput" /><br /><br /><button id="btn_consoleinput_send">Send</button></div></fieldset>
    <br />
    <fieldset><legend>Messages</legend><div id="div_msglog" style="font-family: monospace; color: #8F8;"></div><br /><button id="btn_consoleclear">Clear</button></div></fieldset>
  </div>
</div><!-- accordion -->



</div><!-- showme -->
</body>
</html>